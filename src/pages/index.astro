---
import BaseLayout from "../layouts/BaseLayout.astro";
import GalleryBodas from "../components/GalleryBodas.astro";
import Lightbox from "../components/Lightbox.astro";
import { t } from "../i18n";
import { portfolioByCategory } from "../data/portfolio";

const dict = t("es");
---
<BaseLayout title={dict.seo.homeTitle} description={dict.seo.homeDescription} noTopPadding snap>
  <section
    id="hero-stage"
    class="relative h-[200vh] overflow-hidden snap-none"
    aria-label="Diapositiva 1"
  >
    <div class="pointer-events-none absolute inset-0 -z-10">
      <div class="absolute -left-28 top-10 h-72 w-72 rounded-full bg-roto/10 blur-3xl"></div>
      <div class="absolute -right-24 bottom-10 h-80 w-80 rounded-full bg-roto/5 blur-3xl"></div>
      <div class="absolute inset-x-0 bottom-[-120px] h-56 bg-gradient-to-t from-carbon/60 to-transparent"></div>
    </div>

    <div class="sticky top-0 flex h-dvh items-center">
      <div class="grid w-full items-center gap-10 px-0 pt-24 lg:grid-cols-12">
        <div id="hero-copy" class="relative z-20 lg:col-span-7">
          <h1 class="text-balance text-4xl font-semibold tracking-tight sm:text-5xl lg:text-6xl">
            {dict.home.h1}
          </h1>
          <p class="mt-5 max-w-xl text-pretty text-base leading-relaxed text-suave sm:text-lg">
            {dict.home.intro}
          </p>
        </div>

        <div class="lg:col-span-5">
          <div class="mx-auto w-full max-w-sm">
            <figure
              id="hero-figure"
              class="overflow-hidden rounded-3xl border border-roto/10 bg-carbon/20 shadow-[0_18px_50px_rgba(0,0,0,0.55)]"
            >
              <img
                src={dict.home.heroImage}
                alt={dict.home.heroAlt}
                class="h-[58dvh] w-full object-cover sm:h-[62dvh] lg:h-[68dvh]"
                loading="eager"
                decoding="async"
              />
            </figure>
          </div>
        </div>
      </div>
    </div>

    <!-- Clon fijo para la transicion (evita "saltos" y permite fullscreen real) -->
    <div id="hero-fx" class="pointer-events-none fixed inset-0 z-10 hidden" aria-hidden="true">
      <div
        id="hero-fx-surface"
        class="absolute left-0 top-0 overflow-hidden border border-roto/10 bg-carbon/20 shadow-[0_18px_50px_rgba(0,0,0,0.55)]"
        style="transform-origin: 0 0; border-radius: 24px; transform: translate3d(0,0,0) scale(1);"
      >
        <img
          src={dict.home.heroImage}
          alt=""
          class="h-full w-full object-cover"
          decoding="async"
          loading="eager"
        />
        <div class="absolute inset-0 bg-gradient-to-t from-carbon/35 via-transparent to-transparent"></div>
      </div>
    </div>
  </section>

  <!-- Diapositiva 2: Portfolio (pantalla completa, sin sticky extra) -->
  <section
    id="portfolio"
    class="min-h-dvh snap-start transition-opacity duration-300"
    style="opacity: 0; pointer-events: none;"
    aria-label="Diapositiva 2"
    aria-hidden="true"
  >
    <div class="pt-24 pb-16">
      <header class="max-w-2xl">
        <p class="text-xs font-medium tracking-[0.22em] text-suave">BODAS</p>
        <h2 class="mt-3 text-balance text-2xl font-semibold tracking-tight text-roto sm:text-3xl">
          Seleccion
        </h2>
      </header>

      <GalleryBodas items={portfolioByCategory.bodas} />
      <Lightbox items={portfolioByCategory.bodas} />
    </div>
  </section>

  <script is:inline>
    // Transicion: la imagen del inicio crece a fullscreen y se desvanece al entrar en portfolio.
    const reduce = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const stage = document.getElementById("hero-stage");
    const fig = document.getElementById("hero-figure");
    const copy = document.getElementById("hero-copy");
    const fx = document.getElementById("hero-fx");
    const surface = document.getElementById("hero-fx-surface");
    const slide2 = document.getElementById("portfolio");

    if (!reduce && stage && fig && fx && surface) {
      const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
      const lerp = (a, b, t) => a + (b - a) * t;
      const easeInOut = (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);
      let raf = 0;
      let start = null;
      const heroImg = fig.querySelector("img");
      let locked = false;
      let pTarget = 0;
      let p = 0;
      let completed = false;
      let htmlOverflow = "";
      let bodyOverflow = "";
      let stageStartY = 0;
      let slide2StartY = 0;
      let startDirty = true;

      const measureAnchors = () => {
        // Posicion absoluta (document) de inicio de stage y slide2.
        // Estas anclas se usan para evitar drift al hacer zoom/resize.
        stageStartY = stage.getBoundingClientRect().top + window.scrollY;
        slide2StartY = slide2 ? slide2.getBoundingClientRect().top + window.scrollY : 0;
      };

      const measure = () => {
        const r = fig.getBoundingClientRect();
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const computed = window.getComputedStyle(fig);
        const radius = Number.parseFloat(computed.borderTopLeftRadius || "24") || 24;

        // Escala necesaria para cubrir viewport manteniendo el centro en el mismo sitio.
        const cover = Math.max(vw / r.width, vh / r.height) * 1.03;

        surface.style.width = `${r.width.toFixed(1)}px`;
        surface.style.height = `${r.height.toFixed(1)}px`;
        surface.style.borderRadius = `${radius.toFixed(1)}px`;

        const startCx = r.left + r.width / 2;
        const startCy = r.top + r.height / 2;

        start = {
          tx: r.left,
          ty: r.top,
          w: r.width,
          h: r.height,
          cx: startCx,
          cy: startCy,
          radius,
          cover
        };
      };

      const lockScroll = () => {
        if (locked) return;
        locked = true;
        htmlOverflow = document.documentElement.style.overflow || "";
        bodyOverflow = document.body.style.overflow || "";
        document.documentElement.style.overflow = "hidden";
        document.body.style.overflow = "hidden";
        // Evita que el scroll "real" se mueva; la animacion se controla por rueda/touch.
        window.scrollTo({ top: stageStartY, behavior: "auto" });
      };

      const unlockScroll = () => {
        if (!locked) return;
        locked = false;
        document.documentElement.style.overflow = htmlOverflow;
        document.body.style.overflow = bodyOverflow;
      };

      const render = (pNow) => {
        // Recalcula solo cuando haga falta (zoom/resize/carga) para evitar jitter.
        if (startDirty) {
          measureAnchors();
          // Si estamos bloqueados, mantenemos el scroll clavado a la ancla.
          if (locked) window.scrollTo({ top: stageStartY, behavior: "auto" });
          measure();
          startDirty = false;
        }

        // En reposo (p=0): muestra el figure real y oculta el clon.
        if (pNow <= 0.0001) {
          fx.classList.add("hidden");
          fig.style.opacity = "1";
          fig.style.pointerEvents = "";
          if (copy) copy.style.opacity = "1";
          return;
        }

        // En animacion: el clon es el objeto movible; el scroll real se bloquea para que "no se sienta".
        fx.classList.remove("hidden");
        fig.style.opacity = "0";
        fig.style.pointerEvents = "none";

        // Fase 1: primeros scrolls centran la imagen y desvanecen el texto.
        const toCenterT = 0.22; // 0..1 -> porcentaje de progreso dedicado a centrar
        const tCenter = clamp(pNow / toCenterT, 0, 1);
        const te = easeInOut(tCenter);

        // El texto se desvanece desde el primer gesto.
        if (copy) {
          copy.style.opacity = String(lerp(1, 0, te));
          copy.style.transform = "none";
        }

        // Centro objetivo: centro de viewport.
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const targetCx = vw * 0.5;
        const targetCy = vh * 0.5;

        // Fase 1: SOLO desplazamiento horizontal (evita el "sube/baja" raro).
        const cxPhase1 = lerp(start.cx, targetCx, te);
        const cyPhase1 = start.cy;

        // Fase 2: una vez centrado, escalar desde el centro para cubrir.
        const tScale = clamp((pNow - toCenterT) / (1 - toCenterT), 0, 1);
        const ps = easeInOut(tScale);
        const scale = lerp(1, start.cover, ps);
        const radius = lerp(start.radius, 0, ps);

        // Alineacion vertical: la hacemos durante el inicio del escalado (no durante el desplazamiento lateral).
        const tY = clamp(tScale / 0.22, 0, 1);
        const cy = lerp(cyPhase1, targetCy, easeInOut(tY));
        const cx = cxPhase1;

        // Con transform-origin 0 0, colocamos la esquina superior izquierda para mantener el centro.
        const tx = cx - (start.w * scale) / 2;
        const ty = cy - (start.h * scale) / 2;

        // Reduce borde/sombra conforme crece (evita "doble marco" visual).
        const frameT = clamp(tScale / 0.55, 0, 1);
        const shadowAlpha = lerp(0.55, 0.0, frameT);
        surface.style.boxShadow = `0 18px 50px rgba(0,0,0,${shadowAlpha.toFixed(3)})`;
        surface.style.borderColor = `rgba(245,245,245,${lerp(0.10, 0.0, frameT).toFixed(3)})`;

        // Fade out final
        const outT = clamp((pNow - 0.82) / 0.18, 0, 1);
        surface.style.opacity = String(lerp(1, 0, outT));
        surface.style.borderRadius = `${radius.toFixed(1)}px`;
        surface.style.transform = `translate3d(${tx.toFixed(1)}px, ${ty.toFixed(1)}px, 0) scale(${scale.toFixed(
          4
        )})`;

        // Diapositiva 2:
        // - Forward: invisible hasta que outT llega a 1 (imagen 100% desvanecida).
        if (slide2) {
          if (completed) {
            slide2.style.opacity = "1";
            slide2.style.pointerEvents = "auto";
            slide2.setAttribute("aria-hidden", "false");
            // Ya estamos en la slide 2: el clon no aporta nada.
            fx.classList.add("hidden");
          } else {
            const show = outT >= 1;
            slide2.style.opacity = show ? "1" : "0";
            slide2.style.pointerEvents = show ? "auto" : "none";
            slide2.setAttribute("aria-hidden", show ? "false" : "true");

            // Al completar (forward), soltamos el scroll y "saltamos" a la diapositiva 2.
            if (show) {
              completed = true;
              unlockScroll();
              slide2.scrollIntoView({ behavior: "auto", block: "start" });
            }
          }
        }
      };

      const tick = () => {
        // Suaviza el input (evita que el gesto se sienta como scroll).
        p += (pTarget - p) * 0.14;
        if (Math.abs(pTarget - p) < 0.0008) p = pTarget;
        render(p);
        if (p !== pTarget) requestAnimationFrame(tick);
      };

      const schedule = () => {
        if (raf) return;
        raf = requestAnimationFrame(() => {
          raf = 0;
          tick();
        });
      };

      measure();

      // Entrada inicial: slide 2 oculta y scroll libre hasta el primer gesto.
      if (slide2) {
        slide2.style.opacity = "0";
        slide2.style.pointerEvents = "none";
        slide2.setAttribute("aria-hidden", "true");
      }

      const resetToSlide1 = () => {
        completed = false;
        pTarget = 0;
        p = 0;
        startDirty = true;
        unlockScroll();
        if (slide2) {
          slide2.style.opacity = "0";
          slide2.style.pointerEvents = "none";
          slide2.setAttribute("aria-hidden", "true");
        }
        window.scrollTo({ top: stageStartY, behavior: "auto" });
        // Espera a que se aplique el scroll antes de re-render para evitar estados intermedios.
        requestAnimationFrame(() => render(0));
      };

      const onWheel = (e) => {
        // Interceptamos:
        // - Forward: desde la diapositiva 1 (arriba) al hacer scroll hacia abajo.
        const atStageTop = Math.abs(window.scrollY - stageStartY) <= 3;
        const atSlide2Top = slide2 ? Math.abs(window.scrollY - slide2StartY) <= 3 : false;

        // Volver de la diapositiva 2 a la 1: efecto simple (sin reverse).
        if (!locked && completed && atSlide2Top && e.deltaY < 0) {
          e.preventDefault();
          resetToSlide1();
          return;
        }

        if (!locked && !atStageTop) return;

        // Cap de delta para trackpads/rueda con picos (evita bugs por saltos enormes).
        const dy = Math.sign(e.deltaY) * Math.min(Math.abs(e.deltaY), 120);

        if (!completed && (locked || dy > 0)) {
          lockScroll();
          e.preventDefault();
          // Ajusta sensibilidad: mas alto = mas "lento"
          pTarget = clamp(pTarget + dy / 1600, 0, 1);
          schedule();
        }

        // Permite "deshacer" dentro de la diapositiva 1 (mientras esta bloqueada),
        // pero no hacemos reverse desde la diapositiva 2.
        if (locked && pTarget > 0 && dy < 0) {
          e.preventDefault();
          completed = false;
          pTarget = clamp(pTarget + dy / 1600, 0, 1);
          schedule();
          if (pTarget <= 0.001) {
            pTarget = 0;
            p = 0;
            render(0);
            unlockScroll();
            window.scrollTo({ top: stageStartY, behavior: "auto" });
          }
        }
      };

      let touchY = 0;
      const onTouchStart = (e) => {
        if (!e.touches?.length) return;
        touchY = e.touches[0].clientY;
      };
      const onTouchMove = (e) => {
        if (!e.touches?.length) return;
        const atStageTop = Math.abs(window.scrollY - stageStartY) <= 3;
        const atSlide2Top = slide2 ? Math.abs(window.scrollY - slide2StartY) <= 3 : false;

        const y = e.touches[0].clientY;
        const dy = touchY - y; // >0: scroll down, <0: scroll up
        touchY = y;

        // Volver de la diapositiva 2 a la 1: efecto simple (sin reverse).
        if (!locked && completed && atSlide2Top && dy < 0) {
          e.preventDefault();
          resetToSlide1();
          return;
        }

        // Forward desde diapositiva 1 (arriba) o mientras estamos bloqueados.
        if (!locked && !atStageTop) return;

        lockScroll();
        e.preventDefault();
        pTarget = clamp(pTarget + dy / 900, 0, 1);
        schedule();

        if (pTarget <= 0.001) {
          pTarget = 0;
          p = 0;
          render(0);
          unlockScroll();
          window.scrollTo({ top: stageStartY, behavior: "auto" });
        }
      };

      window.addEventListener("wheel", onWheel, { passive: false });
      window.addEventListener("touchstart", onTouchStart, { passive: true });
      window.addEventListener("touchmove", onTouchMove, { passive: false });

      window.addEventListener("resize", () => {
        start = null;
        startDirty = true;
        schedule();
      });

      // Zoom en algunos navegadores dispara eventos en visualViewport (mas fiable que resize).
      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", () => {
          start = null;
          startDirty = true;
          schedule();
        });
        window.visualViewport.addEventListener("scroll", () => {
          start = null;
          startDirty = true;
          schedule();
        });
      }

      // Fuentes o imagen pueden cambiar medidas tras el primer render.
      if (document.fonts?.ready) {
        document.fonts.ready.then(() => {
          start = null;
          startDirty = true;
          schedule();
        });
      }
      if (heroImg) {
        const refresh = () => {
          start = null;
          startDirty = true;
          schedule();
        };
        heroImg.addEventListener("load", refresh, { once: true });
        heroImg.decode?.().then(refresh).catch(() => {});
      }
      // Render frame 0
      startDirty = true;
      render(0);
    }

    // Sin animaciones (reduce motion): muestra la diapositiva 2 normal.
    if (reduce && slide2) {
      slide2.style.opacity = "1";
      slide2.style.pointerEvents = "auto";
      slide2.setAttribute("aria-hidden", "false");
    }
  </script>
</BaseLayout>
